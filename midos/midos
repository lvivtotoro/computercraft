--- An operating system created by Midnightas, designed to be similar to Windows 10
-- @module midos

local util = {}
util.screenW, util.screenH = term.getSize()

--- Get directory of the file executed
-- @return current directory
util.getWorkingDirectory = function()
	local runningProgram = shell.getRunningProgram()
	local programName = fs.getName(runningProgram)
	local result = runningProgram:sub(1, #runningProgram - #programName)
	return #result == 0 and "/" or result
end

--- Split a string by a seperator
-- @return the splitted string
util.splitString = function(regex, string, times)
	local tab = {}
	local startt = 1
	local positie, eindpos = string.find(string .. "", regex, startt)
	if not times then
		times = 0
	end
	local i = 1
	while times == 0 or (positie and i <= times)  do
		if not positie then
			break
		end
		table.insert(tab, string.sub(string .. "", startt, positie - 1))
		startt = eindpos + 1
		positie, eindpos = string.find(string .. "", regex, startt)
		i = i + 1
	end
	table.insert(tab, string.sub(string .. "", startt, -1))
	return(tab)
end

function table.val_to_str ( v )
	if "string" == type( v ) then
		v = string.gsub( v, "\n", "\\n" )
		if string.match( string.gsub(v,"[^'\"]",""), '^"+$' ) then
			return "'" .. v .. "'"
		end
		return '"' .. string.gsub(v,'"', '\\"' ) .. '"'
	else
		return "table" == type( v ) and table.tostring( v ) or
		tostring( v )
	end
end

function table.key_to_str ( k )
	if "string" == type( k ) and string.match( k, "^[_%a][_%a%d]*$" ) then
		return k
	else
		return "[" .. table.val_to_str( k ) .. "]"
	end
end

function table.tostring(tbl)
	local result, done = {}, {}
	for k, v in ipairs(tbl) do
		table.insert(result, table.val_to_str(v))
		done[k] = true
	end
	for k, v in pairs(tbl) do
		if not v == "_class_" then
		if not done[k] then
		table.insert(result,
			table.key_to_str(k) .. "=" .. table.val_to_str(v))
		end
		end
	end
	return tbl._class_ .. "{" .. table.concat( result, "," ) .. "}"
end

local midos = {}

midos.apps = {}
midos.interfaces = {}
midos.langs = {}
midos.langs["en"] = "English"
midos.lang = "en"
midos.appsDir = util.getWorkingDirectory() .. "apps/"

local interface = nil

--- Register an application
-- This is local as midinst automatically installs programs for you externally
-- @param id The identification for midos to use when referencing this program
-- @param name The name to be shown in menus, desktops, etc..
midos.registerApp = function(id, name, filename)
	if #name > 7 then error("App name cannot be bigger than 7 characters.") end
	midos.apps[id] = {}
	midos.apps[id].name = name
	midos.apps[id].filename = filename or name .. ".midos"
end

--- Read a configuration in this format: key="value"
-- @param content the config to read
-- @return a key-value pair table containing the config settings
midos.readConfig = function(content)
	local result = {}
	for k, line in pairs(util.splitString("\n", content)) do
		local theLine = util.splitString("=", line, 1)
		local key = theLine[1]
		local value = theLine[2]
		value = string.sub(value, 2, #value - 1)
	end
end

--- Creates a table with button information. Used for MidOS interfaces
-- @param x the x coordinate of the button
-- @param y the y coordinate of the button
-- @param w the width of the button
-- @param h the height of the button
-- @param fixed whether or not the button should move along with mouse scrolling
-- @param onClick a function to run when this button is clicked. Function has one argument: the mouse button it is clicked with.
-- @param draw a function to run when attempting to draw this button. Arguments: x y
-- @return the new button
midos.createInterfaceButton = function(x, y, w, h, fixed, onClick, draw)
	local newButton = {}
	newButton._class_ = "Button"
	newButton.x = x
	newButton.y = y
	newButton.w = w
	newButton.h = h
	newButton.fixed = fixed
	newButton.onClick = onClick
	newButton.draw = draw
	return newButton
end

--- Create a new interface for MidOS
-- @param bg the background color of the interface
-- @param fg the foreground color of the interface
-- @param scrollable whether the mouse scroller should move the objects in the interface
-- @param maxScrollAmount max amount of scroll's' for the interface
-- @return the new interface
midos.createInterface = function(bg, fg, scrollable, maxScrollAmount)
	local newInterface = {}
	newInterface._class_ = "Interface"
	newInterface.buttons = {}
	newInterface.drawFunctions = {}
	newInterface.bg = bg
	newInterface.fg = fg
	newInterface.scrollable = scrollable
	newInterface.maxScrollAmount = maxScrollAmount
	newInterface.scrolled = 0
	newInterface.addButton = function(button)
		table.insert(newInterface.buttons, button)
	end
	newInterface.draw = function(func)
		table.insert(newInterface.drawFunctions, func)
	end
	return newInterface
end

--- Creates a function for drawing simple text buttons
-- @param text the text in the button
-- @param bg The background of the button. Can be nil
-- @param fg The foreground of the button. Can be nil
-- @return the new button draw function
midos.createTextButtonDraw = function(text, bg, fg)
	return function(x, y)
		if bg ~= nil then term.setBackgroundColor(bg) end
		if fg ~= nil then term.setTextColor(fg) end
		write(text)
	end
end

--- Draw everything
midos.draw = function()
	term.setBackgroundColor(interface.bg)
	term.setTextColor(interface.fg)
	term.clear()
	for k, v in pairs(interface.drawFunctions) do
		v()
	end
	for k, v in pairs(interface.buttons) do
		if v.draw ~= nil then
			term.setCursorPos(v.x, v.y)
			v.draw(v.x, v.y)
		end
	end
end

-- setup default interfaces to not reset them everytime they open

local loadedApps = {}
for _, v in pairs(fs.list(midos.appsDir)) do
	local appLoc = midos.appsDir .. v
	if not fs.isDir(appLoc) then
		local bytecode = fs.open(appLoc, "rb")
		local stack = {}
		stack._class_ = "MidOSStack"
		while true do
			local b = bytecode.read()
			if b == nil then break end
			if b == 0x00 then table.insert(stack, 0) end
			if b == 0x01 then table.insert(stack, 1) end
			if b == 0x02 then table.insert(stack, 2) end
			if b == 0x03 then table.insert(stack, 3) end
			if b == 0x04 then table.insert(stack, 4) end
			if b == 0x05 then table.insert(stack, 5) end
			if b == 0x06 then table.insert(stack, 6) end
			if b == 0x07 then table.insert(stack, 7) end
			if b == 0x08 then table.insert(stack, 8) end
			if b == 0x09 then table.insert(stack, 9) end
		end
		print(table.tostring(stack))
	end
end

midos.interfaces["pusk"] = midos.createInterface(colors.white, colors.black, true)
midos.interfaces["pusk"].addButton(midos.createInterfaceButton(1, util.screenH, 1, 1, true, function(button)
end, function(x, y)
end))
midos.interfaces["pusk"].draw(function()
end)

loadedApps = {}

midos.interfaces["desktop"] = midos.createInterface(colors.white, colors.black, false)
midos.interfaces["desktop"].addButton(midos.createInterfaceButton(1, util.screenH, 1, 1, true, function(button)
	interface = midos.interfaces["pusk"]
end, midos.createTextButtonDraw("O", colors.lightGray, colors.black)))
midos.interfaces["desktop"].draw(function()
	term.setCursorPos(util.screenW - 4, util.screenH)
	write(textutils.formatTime(os.time(), true))
end)

-- begin the os

error("")

interface = midos.interfaces["desktop"]

while true do
	term.setBackgroundColor(colors.black)
	term.setTextColor(colors.white)
	term.clear()
	midos.draw()
	os.startTimer(0.25)
	local event, arg1, arg2, arg3 = os.pullEvent()
	if event == "mouse_click" then
		for k, aButton in pairs(interface.buttons) do
			if arg2 >= aButton.x and arg2 <= aButton.x + aButton.w - 1 and arg3 >= aButton.y and arg3 <= aButton.y + aButton.h - 1 then
				aButton.onClick()
				print(aButton)
			end
		end
	end
end